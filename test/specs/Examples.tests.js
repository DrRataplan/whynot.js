define(
	[
		'whynot',
		'regexParser'
	],
	function(
		whynot,
		regexParser
		) {
		'use strict';

		describe('whynot.js examples', function() {
			// All whynot VMs expect to receive their input through a function that returns the
			// items one by one. The function should return null to indicate the end of input.
			// Here's a simple helper which creates this iterator based on a string or array:
			function createInput(array) {
				var i = 0;
				return function() {
					return array[i++] || null;
				};
			}

			// whynot.js was designed to answer the question of *why* a given input does not match
			// a given grammar. It can sometimes even tell you how to extend the input so that it
			// will match. To illustrate this, consider a simple subset of regular expressions.
			describe('regular expressions', function() {

				// We have generated a very simple parser using PEG.js for the subset of regular
				// expressions consisting of character matches (a-z, lower case), sequences,
				// choices ("|") and grouping using parentheses ("(" and ")"). This will create
				// an AST as a set of nested arrays, starting with the type of AST node, followed
				// by its children.
				// The compile function traverses the AST recursively and generates a whynot
				// program using the provided assembler.
				function compile(assembler, ast, recordMissing) {
					var i, l = ast.length;
					switch (ast[0]) {
						case 'test':
							// A test represents an expected character, e.g., /a/
							if (!recordMissing) {
								// Normally, it is simply represented by a test instruction which
								// fails if the input character is not the expected character.
								assembler.test(function(input) { return input == ast[1]; });
							} else {
								// To record missing characters, we add a branch for each allowing
								// the VM to skip the character. In both cases, we use a record
								// instruction to remember the character when it is processed.
								assembler.record(ast[1]);
								var skipTest = assembler.jump([]);
								// Branch for existing character
								skipTest.data.push(assembler.program.length);
								assembler.test(function(input) { return input == ast[1]; });
								var skipBad = assembler.jump([]);
								// Branch for missing character
								skipTest.data.push(assembler.program.length);
								// Prefer the branch where the character exists
								assembler.bad();
								// Join both branches to continue execution
								skipBad.data.push(assembler.program.length);
							}
							return;
						case 'seq':
							// A sequence of characters and/or groups, e.g., /abc/
							// This is represented in the program by simply executing its parts in
							// the specified order.
							for (i = 1; i < l; ++i) {
								compile(assembler, ast[i], recordMissing);
							}
							return;
						case 'choice':
							// Alternatives, e.g., /a|b|c/
							// These are represented in the VM by forking execution to all options
							// in parallel and merging the surviving threads afterwards.
							var fork = assembler.jump([]),
								joins = [];
							for (i = 1; i < l; ++i) {
								fork.data.push(assembler.program.length);
								compile(assembler, ast[i], recordMissing);
								joins.push(assembler.jump([]));
							}
							joins.forEach(function(join) {
								join.data.push(assembler.program.length);
							});
							return;
					}
				}

				// We can now define a simple helper to glue everything together
				function compileRegexVM(regex, recordMissing) {
					// Use the generated parser for a quick AST
					var ast = regexParser.parse(regex);

					// Compile the AST into a whynot VM
					return whynot.compileVM(function(assembler) {
						compile(assembler, ast, recordMissing);
						// Any threads that made it to the end of the program have successfully
						// matched the complete input and can be accepted.
						assembler.accept();
					});
				}

				// One more quick helper to pull full strings out of the trace trees generated by
				// the VM when it is recording its progression.
				function flattenRecordStrings(traces, head, flatRecords) {
					chai.expect(traces).to.be.an.instanceOf(Array);
					if (!Array.isArray(head)) {
						head = [];
						flatRecords = [];
					}

					// Generate combined strings for each trace in the array
					for (var i = 0, l = traces.length; i < l; ++i) {
						var trace = traces[i];

						// Combine the records found so far with those of this trace
						var combinedHead = trace.records.concat(head);

						if (!trace.prefixes.length) {
							// Beginning of trace reached, add full record string
							flatRecords.push(combinedHead.join(''));
						} else {
							// Recurse into prefixes
							flattenRecordStrings(trace.prefixes, combinedHead, flatRecords);
						}
					}
					return flatRecords;
				}

				it('can perform simple matching', function() {
					// If a VM can detect how to fix a string, it should first be able to tell if
					// it was broken in the first place. Executing the plain program should do
					// just that. If it returns any traces, these represent how the program was
					// able to match the input. If it doesn't, the input did not match in any way.
					var vm = compileRegexVM('abc(d|e)f', false);

					// This regex should match the string 'abcdf'
					var matchingResult = vm.execute(createInput('abcdf'));
					chai.expect(matchingResult.success).to.equal(true);
					chai.expect(matchingResult.acceptingTraces.length).to.equal(1);

					// But it won't match the string 'abcf'
					var failingResult = vm.execute(createInput('abcf'));
					chai.expect(failingResult.success).to.equal(false);
					chai.expect(failingResult.acceptingTraces.length).to.equal(0);
					// It will, however, return the last failing traces
					chai.expect(failingResult.failingTraces.length).to.equal(2);
				});

				it('can complete a string based on a regex', function() {
					// The real fun starts when you add the additional instructions to allow and
					// detect missing characters. Now the traces returned by the VM can tell you
					// how to fix the input, provided it can be fixed by adding more characters.
					var vm = compileRegexVM('(a|(bc))d(e|f)', true);
					// There are a few branches in this regex, we get different results based on
					// which choices we remove by adding characters to the input.
					// For instance, 'ad' fixes the first choice but not the second, so we get two
					// results:
					chai.expect(flattenRecordStrings(vm.execute(createInput('ad')).acceptingTraces))
						.to.deep.equal(['ade', 'adf']);
					// Fixing both choices yields only a single result:
					chai.expect(flattenRecordStrings(vm.execute(createInput('bf')).acceptingTraces))
						.to.deep.equal(['bcdf']);
					// While leaving both open generates all strings accepted by the regex:
					chai.expect(flattenRecordStrings(vm.execute(createInput('d')).acceptingTraces))
						.to.deep.equal(['ade', 'bcde', 'adf', 'bcdf']);
					// Finally, presenting an input which can not be made to match by adding
					// characters yields no results:
					chai.expect(flattenRecordStrings(vm.execute(createInput('abc')).acceptingTraces))
						.to.deep.equal([]);
				});
			});
		});
	}
);
